
/*
 * Moralis API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 2
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type NativeApiService service
/*
NativeApiService Gets block contents by block hash
Gets the contents of a block by block hash
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param blockNumberOrHash The block hash or block number
 * @param optional nil or *NativeApiGetBlockOpts - Optional Parameters:
     * @param "Chain" (optional.Interface of ChainList) -  The chain to query
     * @param "Subdomain" (optional.String) -  The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
@return Block
*/

type NativeApiGetBlockOpts struct {
    Chain optional.Interface
    Subdomain optional.String
}

func (a *NativeApiService) GetBlock(ctx context.Context, blockNumberOrHash string, localVarOptionals *NativeApiGetBlockOpts) (Block, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Block
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/block/{block_number_or_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"block_number_or_hash"+"}", fmt.Sprintf("%v", blockNumberOrHash), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Chain.IsSet() {
		localVarQueryParams.Add("chain", parameterToString(localVarOptionals.Chain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Subdomain.IsSet() {
		localVarQueryParams.Add("subdomain", parameterToString(localVarOptionals.Subdomain.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v Block
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NativeApiService Gets events by topic
Gets events in descending order based on block number
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param topic The topic of the event
 * @param address address
 * @param optional nil or *NativeApiGetContractEventsOpts - Optional Parameters:
     * @param "Body" (optional.Interface of interface{}) -  ABI of the specific event
     * @param "Chain" (optional.Interface of ChainList) -  The chain to query
     * @param "Subdomain" (optional.String) -  The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param "ProviderUrl" (optional.String) -  web3 provider url to user when using local dev chain
     * @param "FromBlock" (optional.Int32) -  The minimum block number from where to get the logs * Provide the param &#x27;from_block&#x27; or &#x27;from_date&#x27; * If &#x27;from_date&#x27; and &#x27;from_block&#x27; are provided, &#x27;from_block&#x27; will be used. 
     * @param "ToBlock" (optional.Int32) -  The maximum block number from where to get the logs. * Provide the param &#x27;to_block&#x27; or &#x27;to_date&#x27; * If &#x27;to_date&#x27; and &#x27;to_block&#x27; are provided, &#x27;to_block&#x27; will be used. 
     * @param "FromDate" (optional.String) -  The date from where to get the logs (any format that is accepted by momentjs) * Provide the param &#x27;from_block&#x27; or &#x27;from_date&#x27; * If &#x27;from_date&#x27; and &#x27;from_block&#x27; are provided, &#x27;from_block&#x27; will be used. 
     * @param "ToDate" (optional.String) -  Get the logs to this date (any format that is accepted by momentjs) * Provide the param &#x27;to_block&#x27; or &#x27;to_date&#x27; * If &#x27;to_date&#x27; and &#x27;to_block&#x27; are provided, &#x27;to_block&#x27; will be used. 
     * @param "Offset" (optional.Int32) -  offset
     * @param "Limit" (optional.Int32) -  limit
@return []LogEvent
*/

type NativeApiGetContractEventsOpts struct {
    Body optional.Interface
    Chain optional.Interface
    Subdomain optional.String
    ProviderUrl optional.String
    FromBlock optional.Int32
    ToBlock optional.Int32
    FromDate optional.String
    ToDate optional.String
    Offset optional.Int32
    Limit optional.Int32
}

func (a *NativeApiService) GetContractEvents(ctx context.Context, topic string, address string, localVarOptionals *NativeApiGetContractEventsOpts) ([]LogEvent, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []LogEvent
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/{address}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", fmt.Sprintf("%v", address), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Chain.IsSet() {
		localVarQueryParams.Add("chain", parameterToString(localVarOptionals.Chain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Subdomain.IsSet() {
		localVarQueryParams.Add("subdomain", parameterToString(localVarOptionals.Subdomain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderUrl.IsSet() {
		localVarQueryParams.Add("providerUrl", parameterToString(localVarOptionals.ProviderUrl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FromBlock.IsSet() {
		localVarQueryParams.Add("from_block", parameterToString(localVarOptionals.FromBlock.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ToBlock.IsSet() {
		localVarQueryParams.Add("to_block", parameterToString(localVarOptionals.ToBlock.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FromDate.IsSet() {
		localVarQueryParams.Add("from_date", parameterToString(localVarOptionals.FromDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ToDate.IsSet() {
		localVarQueryParams.Add("to_date", parameterToString(localVarOptionals.ToDate.Value(), ""))
	}
	localVarQueryParams.Add("topic", parameterToString(topic, ""))
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []LogEvent
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NativeApiService Gets the closest block of the provided date
Gets the closest block of the provided date
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param date Unix date in miliseconds or a datestring (any format that is accepted by momentjs)
 * @param optional nil or *NativeApiGetDateToBlockOpts - Optional Parameters:
     * @param "Chain" (optional.Interface of ChainList) -  The chain to query
     * @param "ProviderUrl" (optional.String) -  web3 provider url to user when using local dev chain
@return BlockDate
*/

type NativeApiGetDateToBlockOpts struct {
    Chain optional.Interface
    ProviderUrl optional.String
}

func (a *NativeApiService) GetDateToBlock(ctx context.Context, date string, localVarOptionals *NativeApiGetDateToBlockOpts) (BlockDate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue BlockDate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/dateToBlock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Chain.IsSet() {
		localVarQueryParams.Add("chain", parameterToString(localVarOptionals.Chain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderUrl.IsSet() {
		localVarQueryParams.Add("providerUrl", parameterToString(localVarOptionals.ProviderUrl.Value(), ""))
	}
	localVarQueryParams.Add("date", parameterToString(date, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v BlockDate
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NativeApiService Gets address logs
Gets the logs from an address
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param address address
 * @param optional nil or *NativeApiGetLogsByAddressOpts - Optional Parameters:
     * @param "Chain" (optional.Interface of ChainList) -  The chain to query
     * @param "Subdomain" (optional.String) -  The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param "BlockNumber" (optional.String) -  The block number * Provide the param &#x27;block_numer&#x27; or (&#x27;from_block&#x27; and / or &#x27;to_block&#x27;) * If &#x27;block_numer&#x27; is provided in conbinaison with &#x27;from_block&#x27; and / or &#x27;to_block&#x27;, &#x27;block_number&#x27; will will be used 
     * @param "FromBlock" (optional.String) -  The minimum block number from where to get the logs * Provide the param &#x27;block_numer&#x27; or (&#x27;from_block&#x27; and / or &#x27;to_block&#x27;) * If &#x27;block_numer&#x27; is provided in conbinaison with &#x27;from_block&#x27; and / or &#x27;to_block&#x27;, &#x27;block_number&#x27; will will be used 
     * @param "ToBlock" (optional.String) -  The maximum block number from where to get the logs * Provide the param &#x27;block_numer&#x27; or (&#x27;from_block&#x27; and / or &#x27;to_block&#x27;) * If &#x27;block_numer&#x27; is provided in conbinaison with &#x27;from_block&#x27; and / or &#x27;to_block&#x27;, &#x27;block_number&#x27; will will be used 
     * @param "FromDate" (optional.String) -  The date from where to get the logs (any format that is accepted by momentjs) * Provide the param &#x27;from_block&#x27; or &#x27;from_date&#x27; * If &#x27;from_date&#x27; and &#x27;from_block&#x27; are provided, &#x27;from_block&#x27; will be used. * If &#x27;from_date&#x27; and the block params are provided, the block params will be used. Please refer to the blocks params sections (block_number,from_block and to_block) on how to use them 
     * @param "ToDate" (optional.String) -  Get the logs to this date (any format that is accepted by momentjs) * Provide the param &#x27;to_block&#x27; or &#x27;to_date&#x27; * If &#x27;to_date&#x27; and &#x27;to_block&#x27; are provided, &#x27;to_block&#x27; will be used. * If &#x27;to_date&#x27; and the block params are provided, the block params will be used. Please refer to the blocks params sections (block_number,from_block and to_block) on how to use them 
     * @param "Topic0" (optional.String) -  topic0
     * @param "Topic1" (optional.String) -  topic1
     * @param "Topic2" (optional.String) -  topic2
     * @param "Topic3" (optional.String) -  topic3
@return LogEventByAddress
*/

type NativeApiGetLogsByAddressOpts struct {
    Chain optional.Interface
    Subdomain optional.String
    BlockNumber optional.String
    FromBlock optional.String
    ToBlock optional.String
    FromDate optional.String
    ToDate optional.String
    Topic0 optional.String
    Topic1 optional.String
    Topic2 optional.String
    Topic3 optional.String
}

func (a *NativeApiService) GetLogsByAddress(ctx context.Context, address string, localVarOptionals *NativeApiGetLogsByAddressOpts) (LogEventByAddress, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue LogEventByAddress
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/{address}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", fmt.Sprintf("%v", address), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Chain.IsSet() {
		localVarQueryParams.Add("chain", parameterToString(localVarOptionals.Chain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Subdomain.IsSet() {
		localVarQueryParams.Add("subdomain", parameterToString(localVarOptionals.Subdomain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BlockNumber.IsSet() {
		localVarQueryParams.Add("block_number", parameterToString(localVarOptionals.BlockNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FromBlock.IsSet() {
		localVarQueryParams.Add("from_block", parameterToString(localVarOptionals.FromBlock.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ToBlock.IsSet() {
		localVarQueryParams.Add("to_block", parameterToString(localVarOptionals.ToBlock.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FromDate.IsSet() {
		localVarQueryParams.Add("from_date", parameterToString(localVarOptionals.FromDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ToDate.IsSet() {
		localVarQueryParams.Add("to_date", parameterToString(localVarOptionals.ToDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Topic0.IsSet() {
		localVarQueryParams.Add("topic0", parameterToString(localVarOptionals.Topic0.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Topic1.IsSet() {
		localVarQueryParams.Add("topic1", parameterToString(localVarOptionals.Topic1.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Topic2.IsSet() {
		localVarQueryParams.Add("topic2", parameterToString(localVarOptionals.Topic2.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Topic3.IsSet() {
		localVarQueryParams.Add("topic3", parameterToString(localVarOptionals.Topic3.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v LogEventByAddress
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NativeApiService Gets NFT transfers by block number or block hash
Gets NFT transfers by block number or block hash
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param blockNumberOrHash The block hash or block number
 * @param optional nil or *NativeApiGetNFTTransfersByBlockOpts - Optional Parameters:
     * @param "Chain" (optional.Interface of ChainList) -  The chain to query
     * @param "Subdomain" (optional.String) -  The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param "Offset" (optional.Int32) -  offset
     * @param "Limit" (optional.Int32) -  limit
     * @param "Cursor" (optional.String) -  The cursor returned in the last response (for getting the next page) 
@return NftTransferCollection
*/

type NativeApiGetNFTTransfersByBlockOpts struct {
    Chain optional.Interface
    Subdomain optional.String
    Offset optional.Int32
    Limit optional.Int32
    Cursor optional.String
}

func (a *NativeApiService) GetNFTTransfersByBlock(ctx context.Context, blockNumberOrHash string, localVarOptionals *NativeApiGetNFTTransfersByBlockOpts) (NftTransferCollection, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue NftTransferCollection
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/block/{block_number_or_hash}/nft/transfers"
	localVarPath = strings.Replace(localVarPath, "{"+"block_number_or_hash"+"}", fmt.Sprintf("%v", blockNumberOrHash), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Chain.IsSet() {
		localVarQueryParams.Add("chain", parameterToString(localVarOptionals.Chain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Subdomain.IsSet() {
		localVarQueryParams.Add("subdomain", parameterToString(localVarOptionals.Subdomain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v NftTransferCollection
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NativeApiService Get transaction details by transaction hash
Gets the contents of a block transaction by hash
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param transactionHash The transaction hash
 * @param optional nil or *NativeApiGetTransactionOpts - Optional Parameters:
     * @param "Chain" (optional.Interface of ChainList) -  The chain to query
     * @param "Subdomain" (optional.String) -  The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
@return BlockTransaction
*/

type NativeApiGetTransactionOpts struct {
    Chain optional.Interface
    Subdomain optional.String
}

func (a *NativeApiService) GetTransaction(ctx context.Context, transactionHash string, localVarOptionals *NativeApiGetTransactionOpts) (BlockTransaction, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue BlockTransaction
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/transaction/{transaction_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_hash"+"}", fmt.Sprintf("%v", transactionHash), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Chain.IsSet() {
		localVarQueryParams.Add("chain", parameterToString(localVarOptionals.Chain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Subdomain.IsSet() {
		localVarQueryParams.Add("subdomain", parameterToString(localVarOptionals.Subdomain.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v BlockTransaction
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
NativeApiService Runs a function of a contract abi
Runs a given function of a contract abi and returns readonly data
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param body Body
 * @param functionName function_name
 * @param address address
 * @param optional nil or *NativeApiRunContractFunctionOpts - Optional Parameters:
     * @param "Chain" (optional.Interface of ChainList) -  The chain to query
     * @param "Subdomain" (optional.String) -  The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
     * @param "ProviderUrl" (optional.String) -  web3 provider url to user when using local dev chain
@return string
*/

type NativeApiRunContractFunctionOpts struct {
    Chain optional.Interface
    Subdomain optional.String
    ProviderUrl optional.String
}

func (a *NativeApiService) RunContractFunction(ctx context.Context, body RunContractDto, functionName string, address string, localVarOptionals *NativeApiRunContractFunctionOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/{address}/function"
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", fmt.Sprintf("%v", address), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Chain.IsSet() {
		localVarQueryParams.Add("chain", parameterToString(localVarOptionals.Chain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Subdomain.IsSet() {
		localVarQueryParams.Add("subdomain", parameterToString(localVarOptionals.Subdomain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProviderUrl.IsSet() {
		localVarQueryParams.Add("providerUrl", parameterToString(localVarOptionals.ProviderUrl.Value(), ""))
	}
	localVarQueryParams.Add("function_name", parameterToString(functionName, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-API-Key"] = key
			
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
